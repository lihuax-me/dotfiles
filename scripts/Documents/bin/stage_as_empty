#!/usr/bin/env bash
# stage-as-empty-gum.sh
# Purpose: interactively select files (untracked or unstaged-modified) and stage them as EMPTY blobs in the index.
# It DOES NOT touch the working tree content.
# Dependencies: bash >= 4, git, gum (https://github.com/charmbracelet/gum)
set -euo pipefail

# ---- Check gum ------------------------------------------------------------
if ! command -v gum >/dev/null 2>&1; then
  echo "gum not found. Please install gum first: https://github.com/charmbracelet/gum" >&2
  exit 1
fi

# ---- Go to repo root ------------------------------------------------------
TOP="$(git rev-parse --show-toplevel 2>/dev/null || true)"
if [[ -z "$TOP" ]]; then
  echo "Not inside a git repository." >&2
  exit 1
fi
# Always operate at repo root to normalize paths
pushd "$TOP" >/dev/null
trap 'popd >/dev/null' EXIT

# ---- Helpers --------------------------------------------------------------
empty_blob() { git hash-object -t blob -w --stdin </dev/null; }
is_tracked() { git ls-files --error-unmatch -z -- "$1" >/dev/null 2>&1; }

status_label() {
  local p="$1"
  if ! is_tracked "$p"; then
    printf "[U]"
  else
    if git diff --name-only -z -- "$p" | grep -qz .; then
      printf "[M]"
    else
      printf "[?]"
    fi
  fi
}

file_mode() {
  local p="$1"
  if [ -x "$p" ]; then printf "100755"; else printf "100644"; fi
}

stage_as_empty() {
  local p="$1"
  # skip symlink and missing
  if [ -L "$p" ]; then echo "skip symlink: $p" >&2; return 0; fi
  if [ ! -e "$p" ]; then echo "skip missing: $p" >&2; return 0; fi

  local MODE EMPTY; MODE=$(file_mode "$p"); EMPTY=$(empty_blob)
  if is_tracked "$p"; then
    git update-index --cacheinfo "$MODE" "$EMPTY" "$p"
  else
    git update-index --add --cacheinfo "$MODE" "$EMPTY" "$p"
  fi
}

# ---- Collect candidates (repo-root-relative) ------------------------------
declare -a CANDIDATES=()
declare -A DEDUPE=()

# Untracked (respect .gitignore)
while IFS= read -r -d '' p; do
  if [ -f "$p" ] || [ -h "$p" ]; then
    if [[ -z "${DEDUPE[$p]:-}" ]]; then
      CANDIDATES+=("$p"); DEDUPE["$p"]=1
    fi
  fi
done < <(git ls-files -o --exclude-standard -z)

# Tracked but unstaged modified
while IFS= read -r -d '' p; do
  if [ -e "$p" ] && { [ -f "$p" ] || [ -h "$p" ]; }; then
    if [[ -z "${DEDUPE[$p]:-}" ]]; then
      CANDIDATES+=("$p"); DEDUPE["$p"]=1
    fi
  fi
done < <(git diff --name-only -z)

if (( ${#CANDIDATES[@]} == 0 )); then
  gum style --foreground 212 "No untracked or unstaged-modified files found. Nothing to stage-as-empty."
  exit 0
fi

# --- Preview unstaged changes before selection ---
gum style --bold --underline "Current unstaged new files:"

# 1) show tracked unstaged changes
# UNSTAGED_DIFF="$(git diff --color=always)"
# if [ -n "$UNSTAGED_DIFF" ]; then
#   echo "$UNSTAGED_DIFF" | gum pager --height 12
# else
#   gum style --foreground 244 "No unstaged changes."
# fi

# 2) show untracked files
UNTRACKED="$(git ls-files --others --exclude-standard)"
if [ -n "$UNTRACKED" ]; then
  echo "$UNTRACKED" | gum style --border normal --padding "0 1" --foreground 212
else
  gum style --foreground 244 "No untracked files."
fi

# ---- Menu -----------------------------------------------------------------
declare -a MENU_ITEMS=() U_ONLY=() M_ONLY=()
for p in "${CANDIDATES[@]}"; do
  label="$(status_label "$p")"
  MENU_ITEMS+=("$label $p")
  [[ "$label" == "[U]" ]] && U_ONLY+=("$p")
  [[ "$label" == "[M]" ]] && M_ONLY+=("$p")
done

gum style --bold --underline "Select files to stage as EMPTY (index only):"
gum style --border normal --padding "0 1" \
"u     => select all [U]" \
"m     => select all [M]" \
"um    => select all [U] and [M]" \
"a     => select all" \
"enter => interactively select"

PRESEL="$(gum input --placeholder "enter to choose manually, or u/m/um/a")"
PRESEL="${PRESEL,,}"

declare -a TO_STAGE=()
case "${PRESEL:-}" in
  u) TO_STAGE=("${U_ONLY[@]}") ;;
  m) TO_STAGE=("${M_ONLY[@]}") ;;
  um|mu|a) TO_STAGE=("${CANDIDATES[@]}") ;;
  "" ) ;;
  * ) gum style --foreground 244 "Unrecognized input: '$PRESEL' — falling back to interactive selection." ;;
esac

if (( ${#TO_STAGE[@]} == 0 )); then
  gum style "Use arrows/typing to filter; <tab> to multi-select; <enter> to confirm."
  SELECTED=$(
    printf "%s\n" "${MENU_ITEMS[@]}" \
    | gum choose --no-limit --cursor-prefix " " --selected-prefix " " --unselected-prefix "  "
  )
  [[ -z "${SELECTED// }" ]] && { gum style --foreground 244 "Cancelled."; exit 0; }
  mapfile -t TO_STAGE < <(printf "%s\n" "$SELECTED" | sed -E 's/^\[[^]]+\] //')
fi

gum style --bold "Will stage as EMPTY in index:"
printf '%s\n' "${TO_STAGE[@]}" | gum style --border normal --margin "0 0" --padding "0 1"

if ! gum confirm "Proceed?"; then
  gum style --foreground 244 "Aborted."
  exit 0
fi

# ---- Execute with a spinner ----------------------------------------------
gum spin --title "Updating index..." -- \
bash -c '
  set -euo pipefail
  empty_blob() { git hash-object -t blob -w --stdin </dev/null; }
  is_tracked() { git ls-files --error-unmatch -z -- "$1" >/dev/null 2>&1; }
  file_mode() { if [ -x "$1" ]; then printf "100755"; else printf "100644"; fi; }
  stage_as_empty_inner() {
    local p="$1"
    if [ -L "$p" ]; then return 0; fi
    if [ ! -e "$p" ]; then return 0; fi
    local MODE EMPTY; MODE=$(file_mode "$p"); EMPTY=$(empty_blob)
    if is_tracked "$p"; then
      git update-index --cacheinfo "$MODE" "$EMPTY" "$p"
    else
      git update-index --add --cacheinfo "$MODE" "$EMPTY" "$p"
    fi
  }
  while IFS= read -r p; do
    stage_as_empty_inner "$p"
  done
' <<<"$(printf '%s\n' "${TO_STAGE[@]}")"

gum style --foreground 212 --bold "Done."
gum style "Verify:"
gum style --border normal --padding "0 1" \
"git diff --cached --stat" \
"git show :<path> | wc -c  # should be 0"
